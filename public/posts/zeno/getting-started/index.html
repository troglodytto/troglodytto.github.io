<!doctype html>
<html
    lang="en-us"
    dir="ltr"
    class="dark"
>
    <head>
        <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
  Getting started | Piyush Upadhyay&#39;s Blog
</title>
 
<link rel="canonical" href="https://troglodytto.github.io/posts/zeno/getting-started/" />


<meta property="og:title" content="Getting started" />

<meta
  property="og:type"
  content="article"
/>
<meta property="og:url" content="https://troglodytto.github.io/posts/zeno/getting-started/" />
 
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Getting started" />
      
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Getting started",
    "url": "https:\/\/troglodytto.github.io\/posts\/zeno\/getting-started\/",
    "datePublished": "2026-01-30T13:38:37\u002b05:30",
    "dateModified": "2026-01-30T13:38:37\u002b05:30"
  }
</script>
 <link rel="apple-touch-icon" sizes="57x57" href="/favicon_io/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/favicon_io/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/favicon_io/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/favicon_io/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/favicon_io/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/favicon_io/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/favicon_io/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/favicon_io/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/favicon_io/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="/favicon_io/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon_io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="/favicon_io/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon_io/favicon-16x16.png">
<link rel="manifest" href="/favicon_io/manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/favicon_io/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">
 
      <link rel="stylesheet" href="/css/main.min.29353c5378846a0bc06f58d4f80a908eecf6618c65dd0c1252ca0511614e1b96.css" integrity="sha256-KTU8U3iEagvAb1jU&#43;AqQjuz2YYxl3QwSUsoFEWFOG5Y=" crossorigin="anonymous">
      <link rel="stylesheet" href="/css/custom.min.b340609f7dd6fc5f5a722bdafe38815d29136b82029e153d8812993aab051ae7.css" integrity="sha256-s0Bgn33W/F9aciva/jiBXSkTa4ICnhU9iBKZOqsFGuc=" crossorigin="anonymous">
 <link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
    href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap"
    rel="stylesheet"
/>


    </head>
    <body>
        <a href="#main-content" class="skip-link">Skip to content</a>
        <header><nav class="path-nav">
  <ol>
    
  
    
  
    
  
    
  
  <li>
    /
    <a href="/">Piyush Upadhyay&#39;s Blog</a>
    /
  </li>

  
  <li>
    
    <a href="/posts/">Posts</a>
    /
  </li>

  
  <li>
    
    <a href="/posts/zeno/">Writing an OS in rust</a>
    /
  </li>

  
  <li class="current">
    
    <a href="/posts/zeno/getting-started/">Getting started</a>
    
  </li>

  </ol>
</nav>



</header>
        <main id="main-content">
  <h1>Getting started</h1>
  


  
  
  
  
    <nav class="toc">
      <strong>Table of contents</strong>
      <div class="toc-content">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#the-why-behind-it">The &ldquo;Why&rdquo; behind it.</a></li>
    <li><a href="#goals">Goals</a></li>
    <li><a href="#some-hard-choices-we-need-to-make">Some hard choices we need to make</a>
      <ul>
        <li><a href="#what-is-our-target-architecture">What is our target architecture?</a></li>
        <li><a href="#which-programming-language-to-use">Which programming language to use?</a></li>
        <li><a href="#how-do-we-boot">How do we boot?</a></li>
      </ul>
    </li>
  </ul>
</nav>
      </div>
    </nav>
  

  
  <h2 id="the-why-behind-it">The &ldquo;Why&rdquo; behind it.</h2>
<p>Writing an OS is hard. Incredibly so.</p>
<p>I&rsquo;ve learned that the hard way while trying to write this blog.</p>
<p>There are a lot of things can go wrong, and not many ways to figure out what did.</p>
<p><strong>But</strong>.. as humans, that is exactly what we like. Things that challenge us, that push us to our limits.</p>
<p>Figuring things out, learning as we encounter new things, and constantly moving forward, that&rsquo;s what we are.</p>
<p>The purpose of writing this OS kernel (as well as this blog series) is to learn, understand, and explore how computers work and to share what I have learned with the world.</p>
<h2 id="goals">Goals</h2>
<p>Let&rsquo;s be real, we won&rsquo;t be competing with Windows, Linux etc anytime soon. Maybe in a few decades, sure. For now, we need to figure out what our goals are, what abilities we want out kernel to have.</p>
<p>Here&rsquo;s a wishlist of items that I want to implement:</p>
<ol>
<li>A kernel that can boot (<em>duh!</em>)</li>
<li>A UI interface (Text or Graphics)</li>
<li>An input / output system (Using keyboard, serial ports etc)</li>
<li>A memory management unit</li>
<li>A CLI shell</li>
<li>Ability to store things i.e a file system</li>
<li>Ability to run arbitrary programs in the user space</li>
<li>Basic Networking (If I see a status 200, I&rsquo;m happy)</li>
<li>A few applications that the user can use, such as
<ul>
<li>A text editor</li>
<li>An http client</li>
<li>Pong? Maybe</li>
</ul>
</li>
</ol>
<p>That list might not seem a lot right now, but we&rsquo;re implementing a <strong>Kernel</strong> which has these abilities, so our main focus will be on that side of the equation.</p>
<h2 id="some-hard-choices-we-need-to-make">Some hard choices we need to make</h2>
<p>Before you even start writing an OS kernel, you&rsquo;ll have a bunch of questions in front of you.</p>
<p>Target Architecture? Programming language? How will you boot?</p>
<p>Let&rsquo;s unpack</p>
<h3 id="what-is-our-target-architecture">What is our target architecture?</h3>
<p>There are god knows how many CPU architectures out there. Targeting all of them at once will be a monumental task. We will have to narrow our choices.</p>
<p>Out of the most popular CPU architectures, such as x86-64, ARM, etc. I&rsquo;ve chosen to target the <code>x86-64</code> CPU architecture, primarily because of its ubiquity, and ecosystem support. The tools we&rsquo;ll be using such as debuggers, virtual emulators, libraries etc support x86 VERY well.</p>
<p>Documentation is another factor. Documentation for other architectures is either sparse or too vendor dependent and changes from vendor to vendor. Since x86 provides a stable-er platform, we wouldn&rsquo;t have to go hunting for our specific spell of magic.</p>
<p>Since this is our proverbial ‘dip in the pond’, I’ll play it on the safe side.</p>
<p>Additionally, I&rsquo;m running an x86-64 CPU, so if I want to test something isolated from the OS kernel&rsquo;s context on my own machine, I can do so easily, which is another added benefit.</p>
<p>So it&rsquo;s settled then. <strong><code>x86-64</code></strong> it is.</p>
<h3 id="which-programming-language-to-use">Which programming language to use?</h3>
<p>We need a programming language that is very minimal, resource efficient, and gives the ability to arbitrarily perform very low level, close to the hardware stuff.</p>
<p>Most of you <em>already</em> have a bunch of ideas in mind.</p>
<p>Perhaps C, or C++, Zig or Rust. Assembly? Nim?</p>
<p>Java?? Yes, People <em>have</em> built OSes in Java (Although the HALs were written in C/C++. Anyway, I digress)</p>
<p>Ugghhh. Choices choices!</p>
<p>C or C++ are fantastic options, They have:</p>
<ul>
<li>A minimal runtime? Check!</li>
<li>A high level of control over how instructions are executed? Check!</li>
<li>Performant? Double Check!</li>
<li>A stable ABI? C does.</li>
</ul>
<p>But are they without chinks in their armor? Ehh&hellip;</p>
<p>They outsource correctness to the programmer. We are the ones who need to make sure we&rsquo;re not accidentally introducing UB in our code.</p>
<p>The price of control, is paid with walking on landmines.</p>
<p>All bets are off. Mistakes, turn into invisible bugs.</p>
<p>Uh.. Oh!</p>
<p>Well.. let&rsquo;s keep exploring.</p>
<p>Zig is interesting. It does tick most of the boxes that C and C++ do. On top of that, it has the added benefit of being very explicit, and having a lot of niceities over C/C++ without compromising anything meaningful, such as comptime, explicit allocations, state of the art error handling.</p>
<p>What about Rust?
Of course it does have the same benfits as the other options.</p>
<p>But additionally, I like the sound of zero cost abstractions. Of a compiler that gently guides me.</p>
<p>Rust also has a strong ecosystem which on the other hand, Zig does not (not yet at least).
That extends to tooling, debugging support, stability (in terms of breaking changes in the language itself)</p>
<p>On top of that it is the language that I&rsquo;m most familiar with. It&rsquo;s better if we stick to things we know and not try to scale two mountains at once.</p>
<p>Final Verdict? We&rsquo;ll use Rust.</p>
<h3 id="how-do-we-boot">How do we boot?</h3>
<p>This one is surprisingly philosophical.</p>
<p>At a very high level, we have two main options:</p>
<ul>
<li>BIOS</li>
<li>UEFI</li>
</ul>
<p>BIOS looks simpler at first glance. And in some ways, it is. You get dropped into a tiny environment, load a few sectors from disk, and jump into your code.</p>
<p>That’s it.</p>
<p>But that’s also the problem.</p>
<p>BIOS doesn’t give you much else:</p>
<ul>
<li>graphics are awkward</li>
<li>memory information is fragmented</li>
<li>modern hardware discovery is painful</li>
<li>everything feels&hellip; old</li>
</ul>
<p>For what we eventually want to build, BIOS alone won’t cut it.</p>
<p><strong>So why not just use UEFI from day one?</strong></p>
<p>Because UEFI is bigger.</p>
<p>More concepts.
More moving parts.
More things to understand at once.</p>
<p>UEFI gives you a lot:</p>
<ul>
<li>framebuffer graphics</li>
<li>clean memory maps</li>
<li>standardized ACPI tables</li>
<li>a 64-bit execution environment from the start</li>
</ul>
<p>All of that is great, but it also adds cognitive load.</p>
<p><strong>The plan</strong>
We’ll start with BIOS. Then implement things using UEFI later.</p>
<p>Once we’ve built something that boots with BIOS, prints text, and doesn’t immediately explode, we’ll move on to UEFI.</p>
<hr>
<p>With that I think we&rsquo;re all set.</p>
<p>Let&rsquo;s start by setting up our our project and preparing our kernel.</p>
<p><a href="../leaving-the-kernel-dependencies-behind">Next: Leaving Kernel Dependencies behind</a></p>

  <div class="time"><time datetime="January 30, 2026">January 30, 2026</time>
</div>

  
  
    <div class="comments">

</div>
  

  
    <div class="terminal-nav">
      <div class="back-nav">
        
          <a href="/posts/zeno/" class="back-link">../</a>
        
      </div>
    </div>
  
</main>
        <footer><p>
    &copy; Copyright 2026 &middot;
    <a href="https://github.com/troglodytto">troglodytto</a>
</p>
</footer>
    </body>
</html>
