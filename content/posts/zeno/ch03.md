+++
date = '2026-02-01T01:10:35+05:30'
draft = false
title = 'Booting into our kernel'
slug = 'booting-into-our-kernel'
+++

-- **This post is a work in progress âš’ï¸** --

In the [last post](../leaving-the-kernel-dependencies-behind), we managed to create a rust binary that is independent of any OS dependencies

We now need to figure out how we will take that binary and convert it to a bootable disk image.

## What happens when a computer turns on?
When a computer powers on, it does not know what an executable is.

All it knows is the following:
- Which device it needs to use for booting.
- A fixed location that it is supposed to read from (in that device)

The CPU itself has its instruction pointer set to a hardwired address called the reset vector.

The [IntelÂ® 64 and IA-32 Architectures Software Developerâ€™s Manual](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html) states: 

> **ðŸ“š First instruction Executed** (Volume 3A. Section 11.1.4)
>
> The first instruction that is fetched and executed following a hardware reset is located at physical address
`0xFFFFFFF0H`.
>
> This address is 16 bytes below the processorâ€™s uppermost physical address. 
>
> The EPROM containing the software-initialization code must be located at this address.

That's a lot of jibber jabber but all we need to focus on right now is that the CPU starts execution at that address.

The motherboard has a fixed set of instructions present at that address called the motherboard firmware.

## What does the motherboard firmware do?

That firmware first makes sure that there isn't anything in your computer that can blow up, using a process called the [**Power-On-Self-Test**](https://en.wikipedia.org/wiki/Power-on_self-test) (or POST for short). Then it initializes a bunch of stuff in your computer such as RAM, hardware devices, PCIe devices and after all that, it figures out which of the disks can be used to boot i.e are "bootable".

After this, a firmware be either one of two kinds.
- The legacy BIOS kind
- The modern UEFI kind

Modern systems usually ship with UEFI support only, along with a separate "Compatibility Support Module" (CSM) that allows the firmware to pretend to be a legacy BIOS based firmware.

We'll first talk about legacy BIOS and then talk about UEFI.

In case of BIOS, when all the startup routines are done, the firmware goes to the selected bootable disk and loads a single sector from `LBA-0` into RAM at address `0x7c00`

> **Sidebar**: Address vs LBA
>
> In order to refer to a location in memory, we usually use the term "address" however, in order to refer to a location on a disk, we use the term "Logical Block Address" (LBA). 
>
> The LBA is a number that represents the sector number/index on the disk. For example, `LBA-0` refers to the first sector on the disk.

Circling back now.

That sector we have read has a special name. It is called the [**Master Boot Record**](https://en.wikipedia.org/wiki/Master_boot_record) and it is exactly 512 bytes (Disks are usually divided into 512 byte sectors)

The Master boot record (MBR) is laid out like this:
- **Section A** (446 bytes) contains the bootloader code
- **Section B** (64 bytes) contains a partition table
- **Section C** (2 bytes) contains an identifier

![MBR Layout | Figure 3.A](/mbr.svg)

The firmware first checks if the 16 bit value present at last 2 bytes of the MBR is equal to `0x55aa`

(at address `0x7c00 + 0x1fe` i.e `0x7dfe` and `0x7c00 + 0x1ff` i.e `0x7dff`.

`0x55aa` is a magic number that basically tells the BIOS that the sector is a valid boot sector

Then, it jumps back to the start (to address `0x7c00`, i.e the "Section A" in Figure 3.A) where our bootloader code can start executing

---

Alright, that was a **\*LOT\*** of information. So let's take a breather and recap
what we've learned so far. Here's what happens when you press the power button on your computer:
1. CPU instruction pointer reset to `0xFFFFFFF0H`
2. Motherboard contains fixed instructions at that address (firmware)
3. Control is handed over to the firmware

Then the firmware does the following:
1. Perform the [**Power-On-Self-Test**](https://en.wikipedia.org/wiki/Power-on_self-test)
2. Initialize a bunch of stuff like, RAM, PCIe devices, disks etc
3. In case we're using **BIOS** firmware, it reads 512 bytes from disk at `LBA-0` and loads them into memory at `0x7c00`
4. Checks if the last 2 bytes of that sector are equal to `0x55aa`
5. If yes, then jump back to the start at address `0x7c00`
6. Start executing code there.

Cool.

Now we can finally start writing some actual code! and run our operating system (at least some semblance of an operating system).

---

We'll start with a bunch of assembly code to at least see *\*some\** output on our screen. And move to a more concrete, permanent bootloader in a bit.

You'll need an assembler to assemble our code (I'm using [`nasm`](https://www.nasm.us/)). 

We also need an emulator to actually run it (I'm using [`qemu-system-x86-64`](https://www.qemu.org/)).

Or maybe if you're brave enough, you can run it on real hardware by flashing it onto a USB drive. ðŸ« 

You can either copy this code as is, or head on over to this post [ðŸ‘‰ Minimal MBR in Assembly](../mbr) for more details

```asm {title="mbr.asm"}
[org 0x7c00]
bits 16

start:
    mov ax, 0xb800
    mov es, ax
    xor di, di
    mov si, msg
    mov cx, msg_end - msg 

.write:
    lodsb    
    mov ah, 0x07
    stosw
    loop .write

.hang:
    jmp .hang

msg db "Hello world!"
msg_end:

times 510 - ($ - $$) db 0

dw 0xAA55
```

Now assemble it with

```fish
# Tell nasm to assemble it in a raw binary format
nasm -f bin mbr.asm -o mbr.bin
```

And finally, run it using QEMU

```fish
# We'll be using qemu to emulate a computer
qemu-system-x86_64 mbr.bin
```

If all goes well, you should see the following screen

![Successful First Boot](/first-boot.png)

## A bootloader
