+++
date = '2026-02-01T01:10:35+05:30'
draft = false
title = 'Booting into our kernel'
slug = 'booting-into-our-kernel'
+++

-- **This post is a work in progress âš’ï¸** --

In the [last post](../leaving-the-kernel-dependencies-behind), we managed to create a rust binary that is independent of any OS dependencies

We now need to figure out how we will take that binary and convert it to a bootable disk image.

## What happens when a computer turns on?
When a computer powers on, it does not know what an executable is.

All it knows is the following:
- Which device it needs to use for booting.
- A fixed location that it is supposed to read from (in that device)

The CPU itself has its instruction pointer set to a hardwired address called the reset vector.

The [IntelÂ® 64 and IA-32 Architectures Software Developerâ€™s Manual](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html) states: 

> **ðŸ“š First instruction Executed** (Volume 3A. Section 11.1.4)
>
> The first instruction that is fetched and executed following a hardware reset is located at physical address
`0xFFFFFFF0H`.
>
> This address is 16 bytes below the processorâ€™s uppermost physical address. 
>
> The EPROM containing the software-initialization code must be located at this address.

That's a lot of jibber jabber but all we need to focus on right now is that the CPU starts execution at that address.

The motherboard has a fixed set of instructions present at that address called the motherboard firmware.

## What does the motherboard firmware do?

That firmware first makes sure that there isn't anything in your computer that can blow up, using a process called the [**Power-On-Self-Test**](https://en.wikipedia.org/wiki/Power-on_self-test) (or POST for short). Then it initializes a bunch of stuff in your computer such as RAM, hardware devices, PCIe devices and after all that, it figures out which of the disks can be used to boot i.e are "bootable".

After this, a firmware be either one of two kinds.
- The legacy BIOS kind
- The modern UEFI kind

Modern systems usually ship with UEFI support only, along with a separate "Compatibility Support Module" (CSM) that allows the firmware to pretend to be a legacy BIOS based firmware.

We'll first talk about legacy BIOS and then talk about UEFI.

In case of BIOS, when all the startup routines are done, the firmware goes to the selected bootable disk and loads a single sector from `LBA-0` into RAM at address `0x7c00`

> **Sidebar**: Address vs LBA
>
> In order to refer to a location in memory, we usually use the term "address" however, in order to refer to a location on a disk, we use the term "Logical Block Address" (LBA). 
>
> The LBA is a number that represents the sector number/index on the disk. For example, `LBA-0` refers to the first sector on the disk.

Circling back now.

That sector read has a special name. It is called the [**Master Boot Record**](https://en.wikipedia.org/wiki/Master_boot_record) and it is exactly 512 bytes (Disks are usually divided into 512 byte sectors)

The Master boot record (MBR) is laid out like this:
- **Section A** (446 bytes) contains the bootloader code
- **Section B** (64 bytes) contains a partition table
- **Section C** (2 bytes) contains an identifier

![MBR Layout | Figure 3.A](/mbr.svg)

The firmware first checks if the 16 bit value at last 2 bytes of the MBR is equal to `0x55aa`

(at address `0x7c00 + 0x1fe` i.e `0x7dfe` and `0x7c00 + 0x1ff` i.e `0x7dff`.

`0x55aa` is a magic number that basically tells the BIOS that the sector is a valid boot sector

Then, it jumps back to the start (to address `0x7c00`, i.e the "Section A" in Figure 3.A) where our bootloader code can start executing

## A bootloader
