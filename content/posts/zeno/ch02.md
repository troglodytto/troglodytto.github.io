+++
date = '2026-01-30T13:38:37+05:30'
draft = false
title = 'Leaving the Kernel dependencies behind'
slug = 'leaving-the-kernel-dependencies-behind'
+++

In the [previous post](../getting-started) we settled on using Rust to write our OS so we'll set up a new rust application.

Make sure you've got rust installed on your computer.

Here's a [guide](https://rust-lang.org/tools/install/) on how to do that.

## Setting up

Now let's create a new rust application. I've chosen to call our OS **"Zeno"** (no particular reason, just sounds cool)

```fish
# create a new cargo project called 'zeno'
$ cargo new zeno

# run our application for good luck
$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/zeno`

Hello, world!
```

Great! the hardest part is done now. Rest will be **easy.**

## Leaving kernel dependencies behind

Next. We need to make sure we remove any connection between our rust binary to our host operating system.

**Here's why:**

By default, rust and its standard library depend heavily on OS abstractions to do a lot of heavylifting for us and thus, it assumes the presence of an underlying OS and the C runtime.

When you invoke the `println!` macro, or allocate memory, and pretty much anything that has to do with I/O, rust makes syscalls to the host operating system to make stuff happen.

However, in our case, **there is no OS**. We are writing our **own** operating system. Which means whatever abstractions rust relies on to perform those tasks, Gone!

We cannot access them anymore so we need to get rid of any reference to them.

Step 1. Tell rust to avoid using the standard library.

We do this by adding the `#![no_std]` attribute at the top of our `main.rs` file.

The `no_std` attribute explicitly blocks rust from linking any parts of its standard library in our binary (which is the rust compiler's default behavior)

Only the `core` library remains. Everything else, that relies on an underlying OS is gone. 

The `core` library is platform agnostic, so we can keep it.

```rust {title="main.rs"}
#![no_std] // ðŸ‘ˆ Add this line

fn main() {
    println!("Hello, world!");
}
```

Pretty simple right? Well not quite. Trying to compile this code quickly reveals that the rust compiler is not happy.

Although it gives pretty helpful error messages.


```sh {title="compiling with the no_std attribute"}
Compiling zeno v0.1.0 (/path/to/zeno)
error: cannot find macro `println` in this scope
--> src/main.rs:4:5
  |
4 |     println!("Hello, world!");
  |     ^^^^^^^

error: `#[panic_handler]` function required, but not found

error: unwinding panics are not supported without std
|
= help: using nightly cargo, use -Zbuild-std with panic="abort" to avoid unwinding
= note: since the core library is usually precompiled with panic="unwind", rebuilding your crate with panic="abort" may not be enough to fix the problem

error: could not compile `zeno` (bin "zeno") due to 3 previous errors
```

Let's unpack this one step at a time

```sh
error: cannot find macro `println` in this scope
```

This is pretty straightforward. We've stripped rust of all its standard library references using the `#![no_std]` attribute. That includes the `println` macro as well.

Unfortunately for us, we can't use that anymore. so we'll have to get rid of those invocations for now. We'll figure out a way to log things later.

```rust {title="main.rs"}
#![no_std]

fn main() {} // ðŸ‘ˆ `println` gone
```


But that's still not enough. There's one more compiler error that remains.

```sh
error: `#[panic_handler]` function required, but not found

error: unwinding panics are not supported without std
```


Hmmm. The [Rustnomicon](https://doc.rust-lang.org/nomicon/panic-handler.html) says (verbatim)

>`#[panic_handler]` is used to define the behavior of `panic!` in `#![no_std]` applications. 
>
> The `#[panic_handler]` attribute must be applied to a function with the following signature 
>
> **fn(&PanicInfo) -> !** 
> 
> Such function must appear once in the dependency graph of a binary / dylib / cdylib crate.

Cool. Let's add that to our code.

```rust {title="main.rs"}
#![no_std]

use core::panic::PanicInfo; // ðŸ‘ˆ Add this line

fn main() {}


// ðŸ‘‡ Add this function (notice the `#[panic_handler]` attribute)
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

Additionally, another one of the default behaviors of the rust compiler is to unwind the stack whenever a program panics. This is done to allow cleanup of resources like memory, files, etc by calling `Drop::drop` methods on each stack frame.

However, a panic in *our* kernel means immediate shutdown i.e aborting the entire kernel. So we tell rust that we are no longer using `unwinding` panics by setting `panic = "abort"` in our `Cargo.toml`

```toml {title="Cargo.toml"}
[profile.dev] # ðŸ‘ˆ For dev mode
panic = "abort"

[profile.release] # ðŸ‘ˆ For release mode
panic = "abort"
```

Lastly, the compiler says:

```sh
error: using `fn main` requires the standard library
  |
  = help: use `#![no_main]` to bypass the Rust generated entrypoint and declare a platform specific entrypoint yourself, usually with `#[no_mangle]`

error: could not compile `zeno` (bin "zeno") due to 1 previous error
```

Alright Rust, Fine! Let's remove the main function, and add the `#![no_main]` attribute as well

```rust {title="main.rs"}
#![no_std]
#![no_main] // ðŸ‘ˆ Add this line

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

Seems straight forward, although a bit counter intuitive. I mean, If we get rid of `main`, then what? We need some kind of entry point into our OS right?

How does the hardware know where to start execution.

We get a hint of that when we try to compile. Albeit in the form of a giant, cryptic error.

In the midst of all the chaos, we see the line

```sh
rust-lld: error: undefined symbol: __libc_start_main
```

Where did this `__libc_start_main` come from?

I thought we told rust to get rid of all references to any system libraries, including `libc`

Yes. Yes we did. And to be fair, Rust did honor our request. Rust did not include any system library references. In fact the error says the same thing too, that we **didn't** find any `__libc_start_main` symbol present

However, rustc is just a compiler

After the rust compiler is done with our code, it passes it to the linker, which then converts our generated code into an executable.

The problem is, the default linker, in this case `rust-lld` assumes that we are using the C runtime, which of course we do not.

**Wait what!?** C has a runtime??

Isn't C one of those languages that can just run without any runtime?

Well.. yes, but not quite.

When you hear the C "runtime", its not a runtime in the traditional sense as in, there's no VM or an interpreter that runs your programs, instead runtime in this case basically means that the `main` function gets wired to the `crt0` startup routines.

The `crt0` routines do a bunch of things including (but not limited to) making sure that you have a valid stack to work with, initializing the heap for you so that you can dynamically allocate memory, and gathering all the arguments to your program as well as the environment variables. 

When you write C programs it's not

```c
void main(int argc, char **argv, char **envp) {
    // ..
}
```

but something along the lines of

```c
int main(int argc, char **argv, char **envp) {
    // ..
}

// ðŸ‘‡ crt0 does this for you
void _start() {
    int argc = ...;
    char **argv = ...;
    char **envp = ...;
    
    /* setup stuff */

    // ðŸ‘‡ Call to the main function that you wrote
    int exit_code = main(
        argc, 
        argv, 
        envp
    ); 
   
    /* cleanup stuff */
    exit(exit_code);
}
```

When you start a program, it doesn't actually jump to the `main` function but instead, it jumps to a symbol called `_start` (unless you intentionally override the default and tell the linker to emit a different `e_entry` ELF header)

In our case, we need to tell the linker to *not* expect the C runtime.

We do this by passing in additional arguments to our command

```sh
# Linux
cargo rustc -- -C link-arg=-nostartfiles

# Windows
cargo rustc -- -C link-args="/ENTRY:_start /SUBSYSTEM:console"

# macOS
cargo rustc -- -C link-args="-e __start -static -nostartfiles"
```

Now, if we try to build our kernel using these arguments

```sh
Compiling zeno v0.1.0 (/path/to/zeno)
 Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.04s
```

ðŸŽ‰ Woohooo!!

We're now completely detached from our OS boundaries and have ventured into the deep waters. We're on our own now.

There's no entry point to our program anymore, so we can't run anything.

But still. At least the code compiles.

In the next post, we'll explore how we'll setup a new entry point to our OS, and also try to get it to boot.
