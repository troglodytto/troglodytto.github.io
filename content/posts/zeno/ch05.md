+++
date = '2026-02-08T17:18:17+05:30'
draft = false
title = 'Serial Output and Debugging'
slug = 'serial-output'
+++

In the [last post](../battle-tested-bootloader), we prepared the foundations for our operating system. We set up a basic build system using Cargo and Rust, and we created a simple bootloader to load our kernel into memory.

In this post, we will explore how to output text to the serial port and how to use it for debugging purposes.

We chose the serial interface because it has very few moving parts. We need a stable communication channel so that, even if everything else fails, we can still observe what is happening inside the kernel.

On top of that, emulators such as QEMU and Bochs allow serial output to be redirected to the host's standard output or to a file. This is extremely useful because it lets us add logging statements to our kernel and observe its behavior externally.

In kernel development, you often won't have a screen, a debugger, or even memory safety. A serial logger is your lifeline. If something crashes later, this is how we'll know where.

## Writing bytes to Serial I/O

Let's start by writing some bytes to the serial port base address and see where that leads us.

```rs {title="kernel/src/main.rs"}
...
fn main() {
    let serial_port = 0x3F8;

    // notice the `b` at the front, which turns a string into
    // a static array of bytes
    for &character in b"Hello, world!" {
        unsafe {
            ::core::arch::asm!(
                "out dx, al",
                in("dx") serial_port,
                in("al") character,
                options(nomem, nostack, preserves_flags)
            );
        }
    }
}
...
```

Here we use inline assembly to execute the `out` instruction, which transfers data from the `al` (or `ax`) register to the specified I/O port.

We specify the I/O port to be `0x3F8` which is the first serial communication port address (`COM1`). Then, in each iteration, we tell the CPU to first load the character into the al register, and then move it to the I/O port.

Additionally, we need to tell QEMU to redirect the Serial I/O over to the host computer's `stdio`. This can be done by adding the following command-line argument to QEMU:

```fish
-device isa-serial,chardev=serial0 -chardev stdio,id=serial0
```

We already did this in our `src/main.rs` file while building the QEMU command, so we don't need to do anything else.

Finally, when we try to run this (via `cargo run uefi` in our root directory), we see the following output (not in QEMU screen, but in the host machine's terminal)

```fish
....
INFO : Map framebuffer
INFO : Allocate bootinfo
INFO : Create Memory Map
INFO : Create bootinfo
INFO : Jumping to kernel entry point at VirtAddr(0x8000001430)
Hello, world! # ðŸ‘ˆ Notice this line
```

Nice! Next, instead of manually writing bytes to I/O ports using inline assembly we will be abstracting it away because inline assembly is not portable and can be difficult to maintain, so we'll use the `x86_64` crate that we installed in our [housekeeping](../housekeeping) chapter and use that instead. This will also showcase how the `x86_64` crate can be used to abstract away low-level details.

```diff {title="kernel/src/main.rs"}
fn main() {
+   use x86_64::instructions::port::Port;
-   let serial_port = 0x3F8;
+   let mut serial_port = Port::<u8>::new(0x3F8);

    for &character in b"Hello, world!" {
        unsafe {
-           ::core::arch::asm!(
-               "out dx, al",
-               in("dx") serial_port,
-               in("al") character,
-               options(nomem, nostack, preserves_flags)
-           );
+           serial_port.write(character);
        }
    }
}
```

Awesome! Run your code once to make sure it still works. It should behave exactly the same way since we have only abstracted away the instructions that we were manually writing.

## Initializing the Serial interface properly

The astute among you might've noticed that we have just written bytes to a port and haven't actually initialized the Serial I/O interface.

This happens to work in our case since QEMU sets things up for us, so we don't have to perform the initialization ourselves. On real hardware, this would likely fail unless we explicitly configure the UART.

In order to make our kernel more robust and portable, we should initialize the Serial I/O interface properly.

The [OS Dev Wiki](https://wiki.osdev.org/Serial_Ports#:~:text=methods%20are%20unavailable.-,Programming%20the%20Serial%20Communications%20Port,-If%20you%20want) states that in order to use the serial port reliably, we must configure its communication parameters. If both ends disagree on these settings, communication fails.

Alright. Let's do that.

The hardware layer responsible for controlling the I/O through the serial port is called the [**Universal Asynchronous Receiver-Transmitter (UART)**](https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter).

We need to be able to program the UART controller in order to control serial behavior.

There are many [UART controller models](https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter#Models) available on x86 systems, however most modern implementations are compatible with the [16550](https://en.wikipedia.org/wiki/16550_UART) specification.

The `uart_16550` crate provides a safe interface to the UART chipset for initializing and controlling serial behavior, hence it would prove beneficial to use it. Let's add that to our kernel.

```fish
# in the `kernel` directory
cargo add uart_16550
```

Then instead of blindly writing bytes to the `COM1` port, we'll first initialize the Serial I/O interface using the `uart_16550` crate and only then, write to the port.

```diff {title="kernel/src/main.rs"}
fn main() {
-   use x86_64::instructions::port::Port;
+   use uart_16550::SerialPort;

-   let mut serial_port = Port::<u8>::new(0x3F8);
+   let mut serial_port = unsafe { SerialPort::new(0x3F8) };
+   serial_port.init();

    for &character in b"Hello, world!" {
-       unsafe {
-          serial_port.write(character);
-       }
+       serial_port.send(character);
    }
}
```

Additionally, we can use Rust's trait system to write bytes in an even simpler way

```diff {title="kernel/src/main.rs"}
- use core::panic::PanicInfo;
// ðŸ‘‡ This allows us to treat the serial port as a Writable target
+ use core::{fmt::Write, panic::PanicInfo};

fn main() {
    use uart_16550::SerialPort;
    let mut serial_port = unsafe { SerialPort::new(0x3F8) };

    serial_port.init();

    // ðŸ‘‡ instead of manually iterating the bytes in our string and writing them out one by one
-   for &character in b"Hello, world!" {
-       serial_port.send(character);
-   }

    // We'll use the write macro with the serial_port as the target.
    // and write our string to it
+   write!(serial_port, "Hello, World!").expect("failed to write to serial output");
}
```

## Using the serial port for logging

As discussed earlier, we want to use the serial port for logging. We'll also implement a few macros for better ergonomics.

By adding the `#[no_std]` attribute, we got rid of Rust stardard library which includes the `dbg!` macro as well, so we'll try to replace it by writing one of our own.

At the end, I'll be super happy if we can get something like this working

```rs
dbg!("This is a log statement");
```

Let's dive in.

We first need to actually _design_ this abstract system.

We need macros that take in arguments, format them, and write the formatted string to a Serial Port. Instead of creating and initializing a Serial Port object each time we want to log something, we'll create a global serial interface object that we can access to log messages from our kernel.

We'll follow the same structure we defined in the [**housekeeping**](../housekeeping) chapter.

Create a new module in the `kernel` crate called `serial.rs`, and import it in the `lib.rs`

```rs {title="kernel/src/lib.rs"}
/// Serial I/O and HAL via UART 16550
pub mod serial;
```

We'll then create a global serial port object like so

```rs {title="kernel/src/serial.rs"}
use uart_16550::SerialPort;

const COM1_UART_PORT: u16 = 0x3F8;

/// Global COM1 Serial I/O Interface
pub static SERIAL1: SerialPort = {
    let mut serial_port = unsafe { SerialPort::new(COM1_UART_PORT) };

    serial_port.init();

    serial_port
};
```

Rust immediately denies this by saying:

```fish
Compiling kernel v0.1.0 (/path/to/zeno/kernel)
error[E0015]: cannot call non-const method `SerialPort::init` in statics
--> kernel/src/serial.rs:9:17
|
9 |     serial_port.init();
|                 ^^^^^^
|
= note: calls in statics are limited to constant functions, tuple structs and tuple variants
= note: consider wrapping this expression in `std::sync::LazyLock::new(|| ...)`

For more information about this error, try `rustc --explain E0015`.
error: could not compile `kernel` (lib) due to 1 previous error
```

Don't worry, this error is expected.

`static` variables are evaluated at compile time and the `init` function has some runtime behavior such as configuring the baud rate, the data bits, parity etc. and hence, it cannot be computed during compilation.

We'll need some sort of lazy initialization primitive in order to fix this.

Rust graciously suggests that we use something called a `std::sync::LazyLock` instead, however given our constraints of a `no_std` environment, the most common and widely used solution for these kinds of scenarios is a crate called `lazy_static` along with its `spin_no_std` feature.

Let's install the crate (make sure to add the `--features spin_no_std` flag as well, so it is `no_std` compatible)

```fish
# in the kernel directory
cargo add lazy_static --features spin_no_std
```

Then, in our `serial.rs` file, wrap our serial object with the `lazy_static!` macro. Remember to add the `ref` after `static`.

```diff {title="kernel/src/serial.rs"}
+ use lazy_static::lazy_static;

+ lazy_static! {
    /// Global COM1 Serial I/O Interface
-    pub static SERIAL1: SerialPort = {
+    pub static ref SERIAL1: SerialPort = {
        let mut serial_port = unsafe { SerialPort::new(COM1_UART_PORT) };

        serial_port.init();

        serial_port
    };
+ }
```

Next, in our `main.rs` file, we'll use the `SERIAL1` static reference and write to it.

```diff {title="kernel/src/main.rs"}
+ use kernel::serial::SERIAL1;

fn main() {
-   use uart_16550::SerialPort;
-   let mut serial_port = unsafe { SerialPort::new(0x3F8) };

-   serial_port.init();

-   write!(serial_port, "Hello, World!").expect("failed to write to serial output");
+   write!(SERIAL1, "Hello, World!").expect("failed to write to serial output");
}
```

Whoops! We have another problem in our hands.
Rust says:

```fish
error[E0596]: cannot borrow data in dereference of `SERIAL1` as mutable
  --> kernel/src/main.rs:86:12
   |
86 |     write!(SERIAL1, "Hello, World!").expect("failed to write to serial output");
   |            ^^^^^^^ cannot borrow as mutable
   |
   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `SERIAL1`

For more information about this error, try `rustc --explain E0596`.
error: could not compile `kernel` (bin "kernel") due to 1 previous error
```

Alright, we need a mutable reference to the `SERIAL1` object, but we can't since it is a static variable. Rust prevents static mutability because it can lead to data races and other concurrency issues.

To fix this, we need some kind of mutual exclusion. We can utilize a mutex but our `no_std` constraint prevents us from using the standard library's `Mutex` so instead, we'll use the `spin` crate, which provides a spinlock implementation of a mutex. (Spin lock is a synchronization primitive that repeatedly tries to acquire the lock in a loop until it is released.)

```fish
# in the kernel directory
cargo add spin
```

and then use the `spin::Mutex` in our serial module

```diff {title="kernel/src/serial.rs"}
+ use spin::Mutex;

- pub static ref SERIAL1: SerialPort = {
+ pub static ref SERIAL1: Mutex<SerialPort> = {
    let mut serial_port = unsafe { SerialPort::new(COM1_UART_PORT) };

    serial_port.init();

-   serial_port
+   Mutex::new(serial_port)
};

```

And in our `main.rs` file, we'll need to acquire the lock before we can write to it which we'll do as follows:

```diff {title="kernel/src/main.rs"}
fn main() {
+   let mut serial_port = SERIAL1.lock();

-   write!(SERIAL1, "Hello, World!").expect("failed to write to serial output");
+   write!(serial_port, "Hello, World!").expect("failed to write to serial output");
}
```

Now when we run our program, it should print "Hello, World!" to the serial output like before.

Next, to improve this even further, we'll create a `print` function to access the serial interface, and an ergonomic macro for us to use (`dbg!`).

```rs {title="kernel/src/serial.rs"}
#[doc(hidden)]
pub fn print(args: ::core::fmt::Arguments<'_>) {
    use core::fmt::Write;

    SERIAL1
        .lock()
        .write_fmt(args)
        .expect("Printing to serial failed");
}

/// Prints to the host through the serial interface.
#[macro_export]
macro_rules! dbg {
    ($($arg:tt)*) => {
        $crate::serial::print(format_args!($($arg)*))
    };
}
```

By using this macro, we'll delegate the locking, formatting, and error handling to the macro itself, hence, simplifying our driver like so:

```diff {title="kernel/src/main.rs"}
- use core::{fmt::Write, panic::PanicInfo};
- use kernel::serial::SERIAL1;
+ use core::panic::PanicInfo;
+ use kernel::dbg;

fn main() {
-   let mut serial_port = SERIAL1.lock();
-   write!(serial_port, "hello, world!").expect("failed to write to serial output");
+   dbg!("Hello, World!"); // ðŸ‘ˆ
}
```

Awesome! We now have a very ergonomic and easy to use `dbg!` macro that mimics the behavior of rust's own `dbg!` macro.

Moving forward, we'll be using this macro extensively throughout the series to log things to our console.

This will accelerate our development process by providing a simple and reliable debugging mechanism.

---

In the next post we'll finally start implementing memory management in order to prepare our OS for further improvements.

[Next: Foundations of memory management](../memory-foundations)
