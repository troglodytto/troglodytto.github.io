+++
date = '2026-02-08T17:18:17+05:30'
draft = false
title = 'Serial Output and Debugging'
slug = 'serial-output'
+++

--- **This post is a work in progress** ---

In the [last post](../battle-tested-bootloader), we prepared the foundations for our operating system. We set up a basic build system using Cargo and Rust, and we created a simple bootloader to load our kernel into memory.

In this post, we will explore how to output text to the serial port and how to use it for debugging purposes.

We chose serial since it has very few moving parts and we need a stable communication channel so even if nothing works, at least we'll know what's going on.

Many emulators such as QEMU and Bochs allow the redirection of serial output to either stdio or a file on the host computer which will be beneficial for us because we can use the Serial I/O as a way to add log statements to our code and observe the behavior from outside the kernel.

## Writing bytes to Serial I/O
Let's start by writing some bytes to the Serial I/O base and see where that gets us.

```rs {title="kernel/src/main.rs"}
...
fn main() {
    let serial_port = 0x3F8;
    
    // notice the `b` at the front, which turns a string into
    // a static array of bytes
    for &character in b"Hello, world!" {
        unsafe {
            ::core::arch::asm!(
                "out dx, al",
                in("dx") serial_port,
                in("al") character,
                options(nomem, nostack, preserves_flags)
            );
        }
    }
}
...
```

Here we use inline assembly to perform an `out` instruction which basically moves data from the `al` (or `ax`) register to the specified I/O port.

We specify the I/O port to be `0x3F8` which is the first serial communication port address (`COM1`). Then, in each iteration, we tell the CPU to first load the character into the al register, and then move it to the I/O port.

Additionally, we need to tell QEMU to redirect the Serial I/O over to the host computer's `stdio`. This can be done by adding the following command-line argument to QEMU:

```fish
-device isa-serial,chardev=serial0 -chardev stdio,id=serial0
```

We already did this in our `src/main.rs` file while building the QEMU command, so we don't need to do anything else.

Finally, when we try to run this (via `cargo run uefi` in our root directory), we see the following output (not in QEMU screen, but in the host machine's terminal)

```fish
....
INFO : Map framebuffer
INFO : Allocate bootinfo
INFO : Create Memory Map
INFO : Create bootinfo
INFO : Jumping to kernel entry point at VirtAddr(0x8000001430)
Hello, world! # ðŸ‘ˆ Notice this line
```

Nice! Next, instead of manually writing bytes to I/O ports using inline assembly we will be abstracting it away because inline assembly is not portable and can be difficult to maintain, so we'll use the `x86_64` crate that we installed in our [housekeeping](../housekeeping) chapter and use that instead.

```diff {title="kernel/src/main.rs"}
fn main() {
+   use x86_64::instructions::port::Port;
-   let serial_port = 0x3F8;
+   let mut serial_port = Port::<u8>::new(0x3F8);

    for &character in b"Hello, world!" {
        unsafe {
-           ::core::arch::asm!(
-               "out dx, al",
-               in("dx") serial_port,
-               in("al") character,
-               options(nomem, nostack, preserves_flags)
-           );
+           serial_port.write(character);
        }
    }
}
```

Awesome! Quickly run your code once to make sure it still works. It should behave exactly the same way since we have only abstracted away the instructions that we were manually writing.

## Initializing the Serial I/O properly
The astute among you might've noticed that we have just written bytes to a port and haven't actually initialized the Serial I/O interface. This happens to work in our case since QEMU sets things up for us, so we don't have to perform the initialization ourselves. However, in order to make our kernel more robust and portable, we should initialize the Serial I/O interface properly.

The [OS Dev Wiki](https://wiki.osdev.org/Serial_Ports#:~:text=methods%20are%20unavailable.-,Programming%20the%20Serial%20Communications%20Port,-If%20you%20want) states:

> If you want to use the serial port for communications, you first have to initialize it. 
>
> You tell it how fast your connection speed between the other computer or device will be (this is called the baud rate)
>
> You must have the same speed as the other device or computer is setup to use, or you will have problems.

Alright. Let's do that.

The hardware layer responsible for controlling the I/O through the serial port is called the **Universal Asynchronous Receiver-Transmitter (UART)**. We need to be able to program the UART chipset in order to control serial behavior.

There are many [UART chipset models](https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter#Models) available on x86, however most modern UART chipsets are compatible with the model [16550](https://en.wikipedia.org/wiki/16550_UART)

The `uart_16550` crate provides a safe interface to the UART chipset for initializing and controlling serial behavior, hence it would prove beneficial to use it. Let's add that to our kernel.

```fish
# in the `kernel` directory
cargo add uart_16550
```

Then instead of blindly writing bytes to the `COM1` port, we'll first initialize the Serial I/O interface using the `uart_16550` crate and only then, write to the port.

```diff {title="kernel/src/main.rs"}
fn main() {
-   use x86_64::instructions::port::Port;
+   use uart_16550::SerialPort;

-   let mut serial_port = Port::<u8>::new(0x3F8);
+   let mut serial_port = unsafe { SerialPort::new(0x3F8) };

    for &character in b"Hello, world!" {
-       unsafe {
-          serial_port.write(character);
-       }
+       serial_port.send(character);
    }
}
```

## Using the serial port for logging
As discussed earlier, we want to use the serial port for logging. We'll also implement a few macros for better ergonomics.

At the end, I'll be super happy if we can get something like this working

```rs
dbg!("A debug log");
info!("An info log");
warn!("A warning log");
error!("An error log");
success!("A success log");
```

Let's dive in.

We first need to design this abstract system. 

We need macros that take in arguments, format them, and write the formatted string to a Serial Port. Instead of creating and initializing a Serial Port object each time we want to log something, we'll create a global serial interface object that we can access to log messages from our kernel.

We'll follow the same structure we defined in the [**housekeeping**](../housekeeping) chapter.

Create a new module in the `kernel` crate called `serial.rs`, and import it in the `lib.rs`

```rs {title="kernel/src/lib.rs"}
mod serial;
```
