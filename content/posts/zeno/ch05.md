+++
date = '2026-02-08T17:18:17+05:30'
draft = false
title = 'Serial Output and Debugging'
slug = 'serial-output'
+++

In the [last post](../battle-tested-bootloader), we prepared the foundations for our operating system. We set up a basic build system using Cargo and Rust, and we created a simple bootloader to load our kernel into memory.

In this post, we will explore how to output text to the serial port and how to use it for debugging purposes.

We chose the serial interface for this purpose since it has very few moving parts and we need a stable communication channel so even if nothing works, at least we'll know what's going on.

On top of that, many emulators such as QEMU and Bochs allow the redirection of serial output to either stdio or a file on the host computer which will be beneficial for us because we can use the Serial I/O as a way to add log statements to our code and observe the behavior from outside the kernel.

## Writing bytes to Serial I/O

Let's start by writing some bytes to the Serial I/O base and see where that leads us.

```rs {title="kernel/src/main.rs"}
...
fn main() {
    let serial_port = 0x3F8;

    // notice the `b` at the front, which turns a string into
    // a static array of bytes
    for &character in b"Hello, world!" {
        unsafe {
            ::core::arch::asm!(
                "out dx, al",
                in("dx") serial_port,
                in("al") character,
                options(nomem, nostack, preserves_flags)
            );
        }
    }
}
...
```

Here we use inline assembly to perform an `out` instruction which basically moves data from the `al` (or `ax`) register to the specified I/O port.

We specify the I/O port to be `0x3F8` which is the first serial communication port address (`COM1`). Then, in each iteration, we tell the CPU to first load the character into the al register, and then move it to the I/O port.

Additionally, we need to tell QEMU to redirect the Serial I/O over to the host computer's `stdio`. This can be done by adding the following command-line argument to QEMU:

```fish
-device isa-serial,chardev=serial0 -chardev stdio,id=serial0
```

We already did this in our `src/main.rs` file while building the QEMU command, so we don't need to do anything else.

Finally, when we try to run this (via `cargo run uefi` in our root directory), we see the following output (not in QEMU screen, but in the host machine's terminal)

```fish
....
INFO : Map framebuffer
INFO : Allocate bootinfo
INFO : Create Memory Map
INFO : Create bootinfo
INFO : Jumping to kernel entry point at VirtAddr(0x8000001430)
Hello, world! # ðŸ‘ˆ Notice this line
```

Nice! Next, instead of manually writing bytes to I/O ports using inline assembly we will be abstracting it away because inline assembly is not portable and can be difficult to maintain, so we'll use the `x86_64` crate that we installed in our [housekeeping](../housekeeping) chapter and use that instead. This will also showcase how the `x86_64` crate can be used to abstract away low-level details.

```diff {title="kernel/src/main.rs"}
fn main() {
+   use x86_64::instructions::port::Port;
-   let serial_port = 0x3F8;
+   let mut serial_port = Port::<u8>::new(0x3F8);

    for &character in b"Hello, world!" {
        unsafe {
-           ::core::arch::asm!(
-               "out dx, al",
-               in("dx") serial_port,
-               in("al") character,
-               options(nomem, nostack, preserves_flags)
-           );
+           serial_port.write(character);
        }
    }
}
```

Awesome! Quickly run your code once to make sure it still works. It should behave exactly the same way since we have only abstracted away the instructions that we were manually writing.

## Initializing the Serial interface properly

The astute among you might've noticed that we have just written bytes to a port and haven't actually initialized the Serial I/O interface. This happens to work in our case since QEMU sets things up for us, so we don't have to perform the initialization ourselves. However, in order to make our kernel more robust and portable, we should initialize the Serial I/O interface properly.

The [OS Dev Wiki](https://wiki.osdev.org/Serial_Ports#:~:text=methods%20are%20unavailable.-,Programming%20the%20Serial%20Communications%20Port,-If%20you%20want) states (verbatim):

> If you want to use the serial port for communications, you first have to initialize it.
>
> You tell it how fast your connection speed between the other computer or device will be (this is called the baud rate)
>
> You must have the same speed as the other device or computer is setup to use, or you will have problems.

Alright. Let's do that.

The hardware layer responsible for controlling the I/O through the serial port is called the [**Universal Asynchronous Receiver-Transmitter (UART)**](https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter). We need to be able to program the UART chipset in order to control serial behavior.

There are many [UART chipset models](https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter#Models) available on x86, however most modern UART chipsets are compatible with the model [16550](https://en.wikipedia.org/wiki/16550_UART)

The `uart_16550` crate provides a safe interface to the UART chipset for initializing and controlling serial behavior, hence it would prove beneficial to use it. Let's add that to our kernel.

```fish
# in the `kernel` directory
cargo add uart_16550
```

Then instead of blindly writing bytes to the `COM1` port, we'll first initialize the Serial I/O interface using the `uart_16550` crate and only then, write to the port.

```diff {title="kernel/src/main.rs"}
fn main() {
-   use x86_64::instructions::port::Port;
+   use uart_16550::SerialPort;

-   let mut serial_port = Port::<u8>::new(0x3F8);
+   let mut serial_port = unsafe { SerialPort::new(0x3F8) };

    for &character in b"Hello, world!" {
-       unsafe {
-          serial_port.write(character);
-       }
+       serial_port.send(character);
    }
}
```

Additionally, we can use rust's trait system to write bytes in an even simpler way

```diff {title="kernel/src/main.rs"}
- use core::panic::PanicInfo;
// ðŸ‘‡ This allows us to treat the serial port as a Writable target
+ use core::{fmt::Write, panic::PanicInfo};

fn main() {
    use uart_16550::SerialPort;
    let mut serial_port = unsafe { SerialPort::new(0x3F8) };

    serial_port.init();

    // ðŸ‘‡ instead of manually iterating the bytes in our string and writing them out one by one
-   for &character in b"Hello, world!" {
-       serial_port.send(character);
-   }

    // We'll use the write macro with the serial_port as the target.
    // and write our string to it
+   write!(serial_port, "Hello, World!").expect("failed to write to serial output");
}
```

## Using the serial port for logging

As discussed earlier, we want to use the serial port for logging. We'll also implement a few macros for better ergonomics.

At the end, I'll be super happy if we can get something like this working

```rs
dbg!("This is a log statement");
```

Let's dive in.

We first need to actually _design_ this abstract system.

We need macros that take in arguments, format them, and write the formatted string to a Serial Port. Instead of creating and initializing a Serial Port object each time we want to log something, we'll create a global serial interface object that we can access to log messages from our kernel.

We'll follow the same structure we defined in the [**housekeeping**](../housekeeping) chapter.

Create a new module in the `kernel` crate called `serial.rs`, and import it in the `lib.rs`

```rs {title="kernel/src/lib.rs"}
/// Serial I/O and HAL via UART 16550
pub mod serial;
```

We'll then create a global serial port object like so

```rs {title="kernel/src/serial.rs"}
use uart_16550::SerialPort;

const COM1_UART_PORT: u16 = 0x3F8;

/// Global COM1 Serial I/O Interface
pub static SERIAL1: SerialPort = {
    let mut serial_port = unsafe { SerialPort::new(COM1_UART_PORT) };

    serial_port.init();

    serial_port
};
```

Rust immediately denies this by saying:

```fish
Compiling kernel v0.1.0 (/path/to/zeno/kernel)
error[E0015]: cannot call non-const method `SerialPort::init` in statics
--> kernel/src/serial.rs:9:17
|
9 |     serial_port.init();
|                 ^^^^^^
|
= note: calls in statics are limited to constant functions, tuple structs and tuple variants
= note: consider wrapping this expression in `std::sync::LazyLock::new(|| ...)`

For more information about this error, try `rustc --explain E0015`.
error: could not compile `kernel` (lib) due to 1 previous error
```

This is because the `init` function has some runtime behavior and hence, it cannot be computed at compile time. Rust graciously suggests that we use something called a `std::sync::LazyLock` instead. `LazyLock` is nothing but a static value that is lazily evaluated and it is initialized on the first access. Even though we're in a `no_std` environment, and hence, can't use the `LazyLock`, that gives us the potential direction we should move towards. Given our constraints of a lazily evaluated value, in a `no_std` environment, the most common and widely used solution for these kinds of scenarios is a crate called `lazy_static`.

Let's install the crate (make sure to add the `--features spin_no_std` flag as well, so it is `no_std` compatible)

```fish
# in the kernel directory
cargo add lazy_static --features spin_no_std
```

Then, in our `serial.rs` file, wrap our serial object with the `lazy_static!` macro. Remember to add the `ref` after `static`.

```diff {title="kernel/src/serial.rs"}
+ use lazy_static::lazy_static;

+ lazy_static! {
    /// Global COM1 Serial I/O Interface
-    pub static SERIAL1: SerialPort = {
+    pub static ref SERIAL1: SerialPort = {
        let mut serial_port = unsafe { SerialPort::new(COM1_UART_PORT) };

        serial_port.init();

        serial_port
    };
+ }
```

Next, in our `main.rs` file, we'll use the `SERIAL1` static reference and write to it.

```diff {title="kernel/src/main.rs"}
+ use kernel::serial::SERIAL1;

fn main() {
-   use uart_16550::SerialPort;
-   let mut serial_port = unsafe { SerialPort::new(0x3F8) };

-   serial_port.init();

-   write!(serial_port, "Hello, World!").expect("failed to write to serial output");
+   write!(SERIAL1, "Hello, World!").expect("failed to write to serial output");
}
```

Whoops! We have another problem in our hands.
Rust says:

```fish
error[E0596]: cannot borrow data in dereference of `SERIAL1` as mutable
  --> kernel/src/main.rs:86:12
   |
86 |     write!(SERIAL1, "Hello, World!").expect("failed to write to serial output");
   |            ^^^^^^^ cannot borrow as mutable
   |
   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `SERIAL1`

For more information about this error, try `rustc --explain E0596`.
error: could not compile `kernel` (bin "kernel") due to 1 previous error
```

Alright, we need a mutable reference to the `SERIAL1` object, but we can't since it is a static variable. Rust prevents static mutability because it can lead to data races and other concurrency issues.

To fix this, we need some kind of mutual exclusion. We can utilize a mutex but our `no_std` constraint prevents us from using the standard library's `Mutex` so instead, we'll use the `spin` crate, which provides a spinlock implementation i.e spin endlessly and keep trying to acquire a lock on the underlying data. Let's add that too

```fish
# in the kernel directory
cargo add spin
```

and then use the `spin::Mutex` in our serial module

```diff {title="kernel/src/serial.rs"}
+ use spin::Mutex;

- pub static ref SERIAL1: SerialPort = {
+ pub static ref SERIAL1: Mutex<SerialPort> = {
    let mut serial_port = unsafe { SerialPort::new(COM1_UART_PORT) };

    serial_port.init();

-   serial_port
+   Mutex::new(serial_port)
};

```

And in our `main.rs` file, we'll need to acquire the lock before we can write to it which we'll do as follows:

```diff {title="kernel/src/main.rs"}
fn main() {
+   let mut serial_port = SERIAL1.lock();

-   write!(SERIAL1, "Hello, World!").expect("failed to write to serial output");
+   write!(serial_port, "Hello, World!").expect("failed to write to serial output");
}
```

Now when we run our program, it should print "Hello, World!" to the serial output like before.

Next, to improve this even further, we'll create a `print` function to access the serial interface, and an ergonomic macro for us to use (`dbg!`).

```rs {title="kernel/src/serial.rs"}
#[doc(hidden)]
pub fn print(args: ::core::fmt::Arguments<'_>) {
    use core::fmt::Write;

    SERIAL1
        .lock()
        .write_fmt(args)
        .expect("Printing to serial failed");
}

/// Prints to the host through the serial interface.
#[macro_export]
macro_rules! dbg {
    ($($arg:tt)*) => {
        $crate::serial::print(format_args!($($arg)*))
    };
}
```

By using this macro, we'll delegate the locking, formatting, and error handling to the macro itself, hence, simplifying our driver like so:

```diff {title="kernel/src/main.rs"}
- use core::{fmt::Write, panic::PanicInfo};
- use kernel::serial::SERIAL1;
+ use core::panic::PanicInfo;
+ use kernel::dbg;

fn main() {
-   let mut serial_port = SERIAL1.lock();
-   write!(serial_port, "hello, world!").expect("failed to write to serial output");
+   dbg!("Hello, World!"); // ðŸ‘ˆ
}
```

Awesome! We now have a very ergonomic and easy to use `dbg!` macro that mimics the behavior of rust's own `dbg!` macro.

Moving forward, we'll be using this macro extensively throughout the series to log things to our console.

This will accelerate our development process a lot by providing a quick and easy way to debug our code.

---

In the next post we'll finally start implementing interrupts and get our OS foundations prepared for further improvements.

[Next: Setting up CPU Interrupts](../setting-up-interrupts)
